"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.usePlayback = void 0;
const react_1 = require("react");
const remotion_1 = require("remotion");
const calculate_next_frame_js_1 = require("./calculate-next-frame.js");
const is_backgrounded_js_1 = require("./is-backgrounded.js");
const use_player_js_1 = require("./use-player.js");
const usePlayback = ({ loop, playbackRate, moveToBeginningWhenEnded, inFrame, outFrame, }) => {
    const frame = remotion_1.Internals.Timeline.useTimelinePosition();
    const config = remotion_1.Internals.useUnsafeVideoConfig();
    const { playing, pause, emitter } = (0, use_player_js_1.usePlayer)();
    const setFrame = remotion_1.Internals.Timeline.useTimelineSetFrame();
    // requestAnimationFrame() does not work if the tab is not active.
    // This means that audio will keep playing even if it has ended.
    // In that case, we use setTimeout() instead.
    const isBackgroundedRef = (0, is_backgrounded_js_1.useIsBackgrounded)();
    const frameRef = (0, react_1.useRef)(frame);
    frameRef.current = frame;
    const lastTimeUpdateEvent = (0, react_1.useRef)(null);
    (0, react_1.useEffect)(() => {
        if (!config) {
            return;
        }
        if (!playing) {
            return;
        }
        let hasBeenStopped = false;
        let reqAnimFrameCall = null;
        const startedTime = performance.now();
        let framesAdvanced = 0;
        const cancelQueuedFrame = () => {
            if (reqAnimFrameCall !== null) {
                if (reqAnimFrameCall.type === 'raf') {
                    cancelAnimationFrame(reqAnimFrameCall.id);
                }
                else {
                    clearTimeout(reqAnimFrameCall.id);
                }
            }
        };
        const stop = () => {
            hasBeenStopped = true;
            cancelQueuedFrame();
        };
        const callback = () => {
            const time = performance.now() - startedTime;
            const actualLastFrame = outFrame !== null && outFrame !== void 0 ? outFrame : config.durationInFrames - 1;
            const actualFirstFrame = inFrame !== null && inFrame !== void 0 ? inFrame : 0;
            const { nextFrame, framesToAdvance, hasEnded } = (0, calculate_next_frame_js_1.calculateNextFrame)({
                time,
                currentFrame: frameRef.current,
                playbackSpeed: playbackRate,
                fps: config.fps,
                actualFirstFrame,
                actualLastFrame,
                framesAdvanced,
                shouldLoop: loop,
            });
            framesAdvanced += framesToAdvance;
            if (nextFrame !== frameRef.current &&
                (!hasEnded || moveToBeginningWhenEnded)) {
                setFrame(nextFrame);
            }
            if (hasEnded) {
                stop();
                pause();
                emitter.dispatchEnded();
                return;
            }
            if (!hasBeenStopped) {
                queueNextFrame();
            }
        };
        const queueNextFrame = () => {
            if (isBackgroundedRef.current) {
                reqAnimFrameCall = {
                    type: 'timeout',
                    // Note: Most likely, this will not be 1000 / fps, but the browser will throttle it to ~1/sec.
                    id: setTimeout(callback, 1000 / config.fps),
                };
            }
            else {
                reqAnimFrameCall = { type: 'raf', id: requestAnimationFrame(callback) };
            }
        };
        queueNextFrame();
        const onVisibilityChange = () => {
            if (document.visibilityState === 'visible') {
                return;
            }
            // If tab goes into the background, cancel requestAnimationFrame() and update immediately.
            // , so the transition to setTimeout() can be fulfilled.
            cancelQueuedFrame();
            callback();
        };
        window.addEventListener('visibilitychange', onVisibilityChange);
        return () => {
            window.removeEventListener('visibilitychange', onVisibilityChange);
            stop();
        };
    }, [
        config,
        loop,
        pause,
        playing,
        setFrame,
        emitter,
        playbackRate,
        inFrame,
        outFrame,
        moveToBeginningWhenEnded,
        isBackgroundedRef,
    ]);
    (0, react_1.useEffect)(() => {
        const interval = setInterval(() => {
            if (lastTimeUpdateEvent.current === frameRef.current) {
                return;
            }
            emitter.dispatchTimeUpdate({ frame: frameRef.current });
            lastTimeUpdateEvent.current = frameRef.current;
        }, 250);
        return () => clearInterval(interval);
    }, [emitter]);
    (0, react_1.useEffect)(() => {
        emitter.dispatchFrameUpdate({ frame });
    }, [emitter, frame]);
};
exports.usePlayback = usePlayback;
