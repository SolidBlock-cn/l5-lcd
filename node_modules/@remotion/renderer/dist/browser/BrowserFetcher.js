"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRevisionInfo = exports.getFolderPath = exports.removeBrowser = exports.localRevisions = exports.download = exports.getDownloadHost = exports.getDownloadsFolder = exports.getPlatform = void 0;
const https = __importStar(require("https"));
const childProcess = __importStar(require("node:child_process"));
const fs = __importStar(require("node:fs"));
const http = __importStar(require("node:http"));
const os = __importStar(require("node:os"));
const path = __importStar(require("node:path"));
const node_util_1 = __importDefault(require("node:util"));
const extract_zip_1 = __importDefault(require("extract-zip"));
const URL = __importStar(require("node:url"));
const node_util_2 = require("node:util");
const assert_1 = require("./assert");
const delete_directory_1 = require("../delete-directory");
const get_download_destination_1 = require("./get-download-destination");
const { PUPPETEER_EXPERIMENTAL_CHROMIUM_MAC_ARM } = process.env;
const downloadURLs = {
    chrome: {
        linux: '%s/chromium-browser-snapshots/Linux_x64/%d/%s.zip',
        mac: '%s/chromium-browser-snapshots/Mac/%d/%s.zip',
        mac_arm: '%s/chromium-browser-snapshots/Mac_Arm/%d/%s.zip',
        win32: '%s/chromium-browser-snapshots/Win/%d/%s.zip',
        win64: '%s/chromium-browser-snapshots/Win_x64/%d/%s.zip',
    },
    firefox: {
        linux: '%s/firefox-%s.en-US.%s-x86_64.tar.bz2',
        mac: '%s/firefox-%s.en-US.%s.dmg',
        win32: '%s/firefox-%s.en-US.%s.zip',
        win64: '%s/firefox-%s.en-US.%s.zip',
    },
};
const browserConfig = {
    chrome: {
        host: 'https://storage.googleapis.com',
        destination: '.chromium',
    },
    firefox: {
        host: 'https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central',
        destination: '.firefox',
    },
};
function archiveName(product, platform, revision) {
    switch (product) {
        case 'chrome':
            switch (platform) {
                case 'linux':
                    return 'chrome-linux';
                case 'mac_arm':
                case 'mac':
                    return 'chrome-mac';
                case 'win32':
                case 'win64':
                    // Windows archive name changed at r591479.
                    return parseInt(revision, 10) > 591479
                        ? 'Thorium_107.0.5271.0\\BIN'
                        : 'chrome-win32';
                default:
                    throw new Error('unknown browser');
            }
        case 'firefox':
            return platform;
        default:
            throw new Error('unknown browser');
    }
}
function _downloadURL(product, platform, host, revision) {
    if (platform === 'win64' || platform === 'win32') {
        return 'https://remotionchromium-binaries.s3.eu-central-1.amazonaws.com/thorium-107.zip';
    }
    return node_util_1.default.format(downloadURLs[product][platform], host, revision, archiveName(product, platform, revision));
}
function handleArm64() {
    let exists = fs.existsSync('/usr/bin/chromium-browser');
    if (exists) {
        return;
    }
    exists = fs.existsSync('/usr/bin/chromium');
    if (exists) {
        return;
    }
    console.error('The chromium binary is not available for arm64.' +
        '\nIf you are on Ubuntu, you can install with: ' +
        '\n\n sudo apt install chromium\n' +
        '\n\n sudo apt install chromium-browser\n');
    throw new Error();
}
const readdirAsync = (0, node_util_2.promisify)(fs.readdir.bind(fs));
const mkdirAsync = (0, node_util_2.promisify)(fs.mkdir.bind(fs));
const unlinkAsync = (0, node_util_2.promisify)(fs.unlink.bind(fs));
const chmodAsync = (0, node_util_2.promisify)(fs.chmod.bind(fs));
function existsAsync(filePath) {
    return new Promise((resolve) => {
        fs.access(filePath, (err) => {
            return resolve(!err);
        });
    });
}
const getPlatform = (product) => {
    const platform = os.platform();
    switch (platform) {
        case 'darwin':
            switch (product) {
                case 'chrome':
                    return os.arch() === 'arm64' &&
                        PUPPETEER_EXPERIMENTAL_CHROMIUM_MAC_ARM
                        ? 'mac_arm'
                        : 'mac';
                case 'firefox':
                    return 'mac';
                default:
                    throw new Error('unknown browser');
            }
        case 'linux':
            return 'linux';
        case 'win32':
            return os.arch() === 'x64' ? 'win64' : 'win32';
        default:
            (0, assert_1.assert)(false, 'Unsupported platform: ' + platform);
    }
};
exports.getPlatform = getPlatform;
const getDownloadsFolder = (product) => {
    return path.join((0, get_download_destination_1.getDownloadsCacheDir)(), browserConfig[product].destination);
};
exports.getDownloadsFolder = getDownloadsFolder;
const getDownloadHost = (product) => {
    return browserConfig[product].host;
};
exports.getDownloadHost = getDownloadHost;
const download = async ({ revision, progressCallback, product, platform, downloadHost, downloadsFolder, }) => {
    const url = _downloadURL(product, platform, downloadHost, revision);
    const fileName = url.split('/').pop();
    (0, assert_1.assert)(fileName, `A malformed download URL was found: ${url}.`);
    const archivePath = path.join(downloadsFolder, fileName);
    const outputPath = (0, exports.getFolderPath)(revision, downloadsFolder, platform);
    if (await existsAsync(outputPath)) {
        return (0, exports.getRevisionInfo)(revision, product);
    }
    if (!(await existsAsync(downloadsFolder))) {
        await mkdirAsync(downloadsFolder, {
            recursive: true,
        });
    }
    // Use system Chromium builds on Linux ARM devices
    if (os.platform() !== 'darwin' && os.arch() === 'arm64') {
        handleArm64();
        return;
    }
    try {
        await _downloadFile(url, archivePath, progressCallback);
        await install(archivePath, outputPath);
    }
    finally {
        if (await existsAsync(archivePath)) {
            await unlinkAsync(archivePath);
        }
    }
    const revisionInfo = (0, exports.getRevisionInfo)(revision, product);
    if (revisionInfo) {
        await chmodAsync(revisionInfo.executablePath, 0o755);
    }
    return revisionInfo;
};
exports.download = download;
const localRevisions = async (downloadsFolder, product, platform) => {
    if (!(await existsAsync(downloadsFolder))) {
        return [];
    }
    const fileNames = await readdirAsync(downloadsFolder);
    return fileNames
        .map((fileName) => {
        return parseFolderPath(product, fileName);
    })
        .filter((entry) => {
        var _a;
        return (_a = (entry && entry.platform === platform)) !== null && _a !== void 0 ? _a : false;
    })
        .map((entry) => {
        return entry.revision;
    });
};
exports.localRevisions = localRevisions;
const removeBrowser = async (revision, folderPath) => {
    (0, assert_1.assert)(await existsAsync(folderPath), `Failed to remove: revision ${revision} is not downloaded`);
    (0, delete_directory_1.deleteDirectory)(folderPath);
};
exports.removeBrowser = removeBrowser;
const getFolderPath = (revision, downloadsFolder, platform) => {
    return path.resolve(downloadsFolder, `${platform}-${revision}`);
};
exports.getFolderPath = getFolderPath;
const getExecutablePath = (product, revision) => {
    const downloadsFolder = (0, exports.getDownloadsFolder)(product);
    const platform = (0, exports.getPlatform)(product);
    const folderPath = (0, exports.getFolderPath)(revision, downloadsFolder, platform);
    if (product === 'chrome') {
        if (platform === 'mac' || platform === 'mac_arm') {
            return path.join(folderPath, archiveName(product, platform, revision), 'Chromium.app', 'Contents', 'MacOS', 'Chromium');
        }
        if (platform === 'linux') {
            return path.join(folderPath, archiveName(product, platform, revision), 'chrome');
        }
        if (platform === 'win32' || platform === 'win64') {
            return path.join(folderPath, archiveName(product, platform, revision), 'thorium.exe');
        }
        throw new Error('Unsupported platform: ' + platform);
    }
    if (product === 'firefox') {
        if (platform === 'mac' || platform === 'mac_arm') {
            return path.join(folderPath, 'Firefox Nightly.app', 'Contents', 'MacOS', 'firefox');
        }
        if (platform === 'linux') {
            return path.join(folderPath, 'firefox', 'firefox');
        }
        if (platform === 'win32' || platform === 'win64') {
            return path.join(folderPath, 'firefox', 'firefox.exe');
        }
        throw new Error('Unsupported platform: ' + platform);
    }
    throw new Error('Unsupported product: ' + product);
};
const getRevisionInfo = (revision, product) => {
    const executablePath = getExecutablePath(product, revision);
    const downloadsFolder = (0, exports.getDownloadsFolder)(product);
    const platform = (0, exports.getPlatform)(product);
    const folderPath = (0, exports.getFolderPath)(revision, downloadsFolder, platform);
    const url = _downloadURL(product, platform, (0, exports.getDownloadHost)(product), revision);
    const local = fs.existsSync(folderPath);
    return {
        revision,
        executablePath,
        folderPath,
        local,
        url,
        product,
    };
};
exports.getRevisionInfo = getRevisionInfo;
function parseFolderPath(product, folderPath) {
    const name = path.basename(folderPath);
    const splits = name.split('-');
    if (splits.length !== 2) {
        return;
    }
    const [platform, revision] = splits;
    if (!revision || !platform || !(platform in downloadURLs[product])) {
        return;
    }
    return { product, platform, revision };
}
function _downloadFile(url, destinationPath, progressCallback) {
    let fulfill;
    let reject;
    const promise = new Promise((x, y) => {
        fulfill = x;
        reject = y;
    });
    let downloadedBytes = 0;
    let totalBytes = 0;
    let lastProgress = Date.now();
    function onData(chunk) {
        downloadedBytes += chunk.length;
        if (Date.now() - lastProgress > 1000) {
            progressCallback(downloadedBytes, totalBytes);
            lastProgress = Date.now();
        }
    }
    const request = httpRequest(url, 'GET', (response) => {
        if (response.statusCode !== 200) {
            const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);
            // consume response data to free up memory
            response.resume();
            reject(error);
            return;
        }
        const file = fs.createWriteStream(destinationPath);
        file.on('close', () => {
            return fulfill(totalBytes);
        });
        file.on('error', (error) => {
            return reject(error);
        });
        response.pipe(file);
        totalBytes = parseInt(response.headers['content-length'], 10);
        response.on('data', onData);
    });
    request.on('error', (error) => {
        return reject(error);
    });
    return promise;
}
function install(archivePath, folderPath) {
    if (archivePath.endsWith('.zip')) {
        return (0, extract_zip_1.default)(archivePath, { dir: folderPath });
    }
    if (archivePath.endsWith('.tar.bz2')) {
        throw new Error('bz2 currently not implemented');
    }
    if (archivePath.endsWith('.dmg')) {
        return mkdirAsync(folderPath).then(() => {
            return _installDMG(archivePath, folderPath);
        });
    }
    throw new Error(`Unsupported archive format: ${archivePath}`);
}
function _installDMG(dmgPath, folderPath) {
    let mountPath;
    return new Promise((fulfill, reject) => {
        const mountCommand = `hdiutil attach -nobrowse -noautoopen "${dmgPath}"`;
        childProcess.exec(mountCommand, (err, stdout) => {
            if (err) {
                return reject(err);
            }
            const volumes = stdout.match(/\/Volumes\/(.*)/m);
            if (!volumes) {
                return reject(new Error(`Could not find volume path in ${stdout}`));
            }
            mountPath = volumes[0];
            readdirAsync(mountPath)
                .then((fileNames) => {
                const appName = fileNames.find((item) => {
                    return typeof item === 'string' && item.endsWith('.app');
                });
                if (!appName) {
                    return reject(new Error(`Cannot find app in ${mountPath}`));
                }
                const copyPath = path.join(mountPath, appName);
                childProcess.exec(`cp -R "${copyPath}" "${folderPath}"`, (_err) => {
                    if (_err) {
                        reject(_err);
                    }
                    else {
                        fulfill();
                    }
                });
            })
                .catch(reject);
        });
    })
        .catch((error) => {
        console.error(error);
    })
        .finally(() => {
        if (!mountPath) {
            return;
        }
        const unmountCommand = `hdiutil detach "${mountPath}" -quiet`;
        childProcess.exec(unmountCommand, (err) => {
            if (err) {
                console.error(`Error unmounting dmg: ${err}`);
            }
        });
    });
}
function httpRequest(url, method, response, keepAlive = true) {
    const urlParsed = URL.parse(url);
    const options = {
        ...urlParsed,
        method,
        headers: keepAlive
            ? {
                Connection: 'keep-alive',
            }
            : undefined,
    };
    const requestCallback = (res) => {
        if (res.statusCode &&
            res.statusCode >= 300 &&
            res.statusCode < 400 &&
            res.headers.location) {
            httpRequest(res.headers.location, method, response);
        }
        else {
            response(res);
        }
    };
    const request = options.protocol === 'https:'
        ? https.request(options, requestCallback)
        : http.request(options, requestCallback);
    request.end();
    return request;
}
