"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAudioChannelsAndDuration = exports.getAudioChannelsAndDurationWithoutCache = void 0;
const call_ffmpeg_1 = require("../call-ffmpeg");
const p_limit_1 = require("../p-limit");
const limit = (0, p_limit_1.pLimit)(1);
const getAudioChannelsAndDurationWithoutCache = async (src) => {
    const args = [
        ['-v', 'error'],
        ['-show_entries', 'stream=channels:format=duration'],
        ['-of', 'default=nw=1'],
        [src],
    ]
        .reduce((acc, val) => acc.concat(val), [])
        .filter(Boolean);
    const task = await (0, call_ffmpeg_1.callFf)('ffprobe', args);
    const channels = task.stdout.match(/channels=([0-9]+)/);
    const duration = task.stdout.match(/duration=([0-9.]+)/);
    const result = {
        channels: channels ? parseInt(channels[1], 10) : 0,
        duration: duration ? parseFloat(duration[1]) : null,
    };
    return result;
};
exports.getAudioChannelsAndDurationWithoutCache = getAudioChannelsAndDurationWithoutCache;
async function getAudioChannelsAndDurationUnlimited(downloadMap, src) {
    if (downloadMap.durationOfAssetCache[src]) {
        return downloadMap.durationOfAssetCache[src];
    }
    const result = await (0, exports.getAudioChannelsAndDurationWithoutCache)(src);
    downloadMap.durationOfAssetCache[src] = result;
    return result;
}
const getAudioChannelsAndDuration = (downloadMap, src) => {
    return limit(() => getAudioChannelsAndDurationUnlimited(downloadMap, src));
};
exports.getAudioChannelsAndDuration = getAudioChannelsAndDuration;
