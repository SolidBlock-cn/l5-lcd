"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderFrames = exports.internalRenderFrames = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const perf_hooks_1 = require("perf_hooks");
const remotion_1 = require("remotion");
const download_and_map_assets_to_file_1 = require("./assets/download-and-map-assets-to-file");
const browser_1 = require("./browser");
const is_target_closed_err_1 = require("./browser/is-target-closed-err");
const TimeoutSettings_1 = require("./browser/TimeoutSettings");
const compress_assets_1 = require("./compress-assets");
const cycle_browser_tabs_1 = require("./cycle-browser-tabs");
const handle_javascript_exception_1 = require("./error-handling/handle-javascript-exception");
const find_closest_package_json_1 = require("./find-closest-package-json");
const get_concurrency_1 = require("./get-concurrency");
const get_duration_from_frame_range_1 = require("./get-duration-from-frame-range");
const get_frame_padded_index_1 = require("./get-frame-padded-index");
const get_frame_to_render_1 = require("./get-frame-to-render");
const jpeg_quality_1 = require("./jpeg-quality");
const make_cancel_signal_1 = require("./make-cancel-signal");
const open_browser_1 = require("./open-browser");
const perf_1 = require("./perf");
const pool_1 = require("./pool");
const prepare_server_1 = require("./prepare-server");
const puppeteer_evaluate_1 = require("./puppeteer-evaluate");
const replace_browser_1 = require("./replace-browser");
const seek_to_frame_1 = require("./seek-to-frame");
const set_props_and_env_1 = require("./set-props-and-env");
const take_frame_and_compose_1 = require("./take-frame-and-compose");
const truthy_1 = require("./truthy");
const validate_scale_1 = require("./validate-scale");
const MAX_RETRIES_PER_FRAME = 1;
const innerRenderFrames = async ({ onFrameUpdate, outputDir, onStart, inputProps, jpegQuality, imageFormat, frameRange, onError, envVariables, onBrowserLog, onFrameBuffer, onDownload, pagesArray, serveUrl, composition, timeoutInMilliseconds, scale, actualConcurrency, everyNthFrame, proxyPort, cancelSignal, downloadMap, muted, makeBrowser, browserReplacer, compositor, sourcemapContext, }) => {
    if (outputDir) {
        if (!node_fs_1.default.existsSync(outputDir)) {
            node_fs_1.default.mkdirSync(outputDir, {
                recursive: true,
            });
        }
    }
    const downloadPromises = [];
    const realFrameRange = (0, get_frame_to_render_1.getRealFrameRange)(composition.durationInFrames, frameRange);
    const framesToRender = (0, get_duration_from_frame_range_1.getFramesToRender)(realFrameRange, everyNthFrame);
    const lastFrame = framesToRender[framesToRender.length - 1];
    const makePage = async (context) => {
        const page = await browserReplacer.getBrowser().newPage(context);
        pagesArray.push(page);
        await page.setViewport({
            width: composition.width,
            height: composition.height,
            deviceScaleFactor: scale,
        });
        const logCallback = (log) => {
            onBrowserLog === null || onBrowserLog === void 0 ? void 0 : onBrowserLog({
                stackTrace: log.stackTrace(),
                text: log.text,
                type: log.type,
            });
        };
        if (onBrowserLog) {
            page.on('console', logCallback);
        }
        const initialFrame = realFrameRange[0];
        await (0, set_props_and_env_1.setPropsAndEnv)({
            inputProps,
            envVariables,
            page,
            serveUrl,
            initialFrame,
            timeoutInMilliseconds,
            proxyPort,
            retriesRemaining: 2,
            audioEnabled: !muted,
            videoEnabled: imageFormat !== 'none',
        });
        await (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
            // eslint-disable-next-line max-params
            pageFunction: (id, defaultProps, durationInFrames, fps, height, width) => {
                window.remotion_setBundleMode({
                    type: 'composition',
                    compositionName: id,
                    compositionDefaultProps: defaultProps,
                    compositionDurationInFrames: durationInFrames,
                    compositionFps: fps,
                    compositionHeight: height,
                    compositionWidth: width,
                });
            },
            args: [
                composition.id,
                composition.defaultProps,
                composition.durationInFrames,
                composition.fps,
                composition.height,
                composition.width,
            ],
            frame: null,
            page,
        });
        page.off('console', logCallback);
        return page;
    };
    const getPool = async (context) => {
        const pages = new Array(actualConcurrency)
            .fill(true)
            .map(() => makePage(context));
        const puppeteerPages = await Promise.all(pages);
        const pool = new pool_1.Pool(puppeteerPages);
        return pool;
    };
    // If rendering a GIF and skipping frames, we must ensure it starts from 0
    // and then is consecutive so FFMPEG recognizes the sequence
    const countType = everyNthFrame === 1 ? 'actual-frames' : 'from-zero';
    const filePadLength = (0, get_frame_padded_index_1.getFilePadLength)({
        lastFrame,
        totalFrames: framesToRender.length,
        countType,
    });
    let framesRendered = 0;
    const poolPromise = getPool(sourcemapContext);
    onStart === null || onStart === void 0 ? void 0 : onStart({
        frameCount: framesToRender.length,
    });
    const assets = new Array(framesToRender.length).fill(undefined);
    let stopped = false;
    cancelSignal === null || cancelSignal === void 0 ? void 0 : cancelSignal(() => {
        stopped = true;
    });
    const renderFrameWithOptionToReject = async ({ frame, index, reject, width, height, }) => {
        const pool = await poolPromise;
        const freePage = await pool.acquire();
        if (stopped) {
            return reject(new Error('Render was stopped'));
        }
        const startTime = perf_hooks_1.performance.now();
        const errorCallbackOnFrame = (err) => {
            reject(err);
        };
        const cleanupPageError = (0, handle_javascript_exception_1.handleJavascriptException)({
            page: freePage,
            onError: errorCallbackOnFrame,
            frame,
        });
        freePage.on('error', errorCallbackOnFrame);
        await (0, seek_to_frame_1.seekToFrame)({ frame, page: freePage });
        if (!outputDir && !onFrameBuffer && imageFormat !== 'none') {
            throw new Error('Called renderFrames() without specifying either `outputDir` or `onFrameBuffer`');
        }
        if (outputDir && onFrameBuffer && imageFormat !== 'none') {
            throw new Error('Pass either `outputDir` or `onFrameBuffer` to renderFrames(), not both.');
        }
        const id = (0, perf_1.startPerfMeasure)('save');
        const frameDir = outputDir !== null && outputDir !== void 0 ? outputDir : downloadMap.compositingDir;
        const { buffer, collectedAssets } = await (0, take_frame_and_compose_1.takeFrameAndCompose)({
            frame,
            freePage,
            height,
            imageFormat,
            output: node_path_1.default.join(frameDir, (0, get_frame_padded_index_1.getFrameOutputFileName)({
                frame,
                imageFormat,
                index,
                countType,
                lastFrame,
                totalFrames: framesToRender.length,
            })),
            jpegQuality,
            width,
            scale,
            downloadMap,
            wantsBuffer: Boolean(onFrameBuffer),
            compositor,
        });
        if (onFrameBuffer) {
            if (!buffer) {
                throw new Error('unexpected null buffer');
            }
            onFrameBuffer(buffer, frame);
        }
        (0, perf_1.stopPerfMeasure)(id);
        const compressedAssets = collectedAssets.map((asset) => (0, compress_assets_1.compressAsset)(assets.filter(truthy_1.truthy).flat(1), asset));
        assets[index] = compressedAssets;
        compressedAssets.forEach((asset) => {
            (0, download_and_map_assets_to_file_1.downloadAndMapAssetsToFileUrl)({
                asset,
                onDownload,
                downloadMap,
            }).catch((err) => {
                onError(new Error(`Error while downloading asset: ${err.stack}`));
            });
        });
        framesRendered++;
        onFrameUpdate === null || onFrameUpdate === void 0 ? void 0 : onFrameUpdate(framesRendered, frame, perf_hooks_1.performance.now() - startTime);
        cleanupPageError();
        freePage.off('error', errorCallbackOnFrame);
        pool.release(freePage);
    };
    const renderFrame = (frame, index) => {
        return new Promise((resolve, reject) => {
            renderFrameWithOptionToReject({
                frame,
                index,
                reject,
                width: composition.width,
                height: composition.height,
            })
                .then(() => {
                resolve();
            })
                .catch((err) => {
                reject(err);
            });
        });
    };
    const renderFrameAndRetryTargetClose = async ({ frame, index, retriesLeft, attempt, }) => {
        try {
            await Promise.race([
                renderFrame(frame, index),
                new Promise((_, reject) => {
                    cancelSignal === null || cancelSignal === void 0 ? void 0 : cancelSignal(() => {
                        reject(new Error(make_cancel_signal_1.cancelErrorMessages.renderFrames));
                    });
                }),
            ]);
        }
        catch (err) {
            if ((0, make_cancel_signal_1.isUserCancelledRender)(err)) {
                throw err;
            }
            if (!(0, is_target_closed_err_1.isTargetClosedErr)(err)) {
                throw err;
            }
            if (stopped) {
                return;
            }
            if (retriesLeft === 0) {
                console.warn(`The browser crashed ${attempt} times while rendering frame ${frame}. Not retrying anymore. Learn more about this error under https://www.remotion.dev/docs/target-closed`);
                throw err;
            }
            console.warn(`The browser crashed while rendering frame ${frame}, retrying ${retriesLeft} more times. Learn more about this error under https://www.remotion.dev/docs/target-closed`);
            await browserReplacer.replaceBrowser(makeBrowser, async () => {
                const pages = new Array(actualConcurrency)
                    .fill(true)
                    .map(() => makePage(sourcemapContext));
                const puppeteerPages = await Promise.all(pages);
                const pool = await poolPromise;
                for (const newPage of puppeteerPages) {
                    pool.release(newPage);
                }
            });
            await renderFrameAndRetryTargetClose({
                frame,
                index,
                retriesLeft: retriesLeft - 1,
                attempt: attempt + 1,
            });
        }
    };
    const progress = Promise.all(framesToRender.map((frame, index) => renderFrameAndRetryTargetClose({
        frame,
        index,
        retriesLeft: MAX_RETRIES_PER_FRAME,
        attempt: 1,
    })));
    const happyPath = progress.then(() => {
        const firstFrameIndex = countType === 'from-zero' ? 0 : framesToRender[0];
        const returnValue = {
            assetsInfo: {
                assets,
                imageSequenceName: `element-%0${filePadLength}d.${imageFormat}`,
                firstFrameIndex,
                downloadMap,
            },
            frameCount: framesToRender.length,
        };
        return returnValue;
    });
    const result = await happyPath;
    await Promise.all(downloadPromises);
    return result;
};
const internalRenderFrames = ({ browserExecutable, cancelSignal, chromiumOptions, composition, concurrency, dumpBrowserLogs, envVariables, everyNthFrame, frameRange, imageFormat, indent, inputProps, jpegQuality, muted, onBrowserLog, onDownload, onFrameBuffer, onFrameUpdate, onStart, outputDir, port, puppeteerInstance, scale, server, timeoutInMilliseconds, verbose, webpackBundleOrServeUrl, }) => {
    remotion_1.Internals.validateDimension(composition.height, 'height', 'in the `config` object passed to `renderFrames()`');
    remotion_1.Internals.validateDimension(composition.width, 'width', 'in the `config` object passed to `renderFrames()`');
    remotion_1.Internals.validateFps(composition.fps, 'in the `config` object of `renderFrames()`', false);
    remotion_1.Internals.validateDurationInFrames({
        durationInFrames: composition.durationInFrames,
        component: 'in the `config` object passed to `renderFrames()`',
        allowFloats: false,
    });
    (0, jpeg_quality_1.validateJpegQuality)(jpegQuality);
    (0, validate_scale_1.validateScale)(scale);
    const makeBrowser = () => (0, open_browser_1.internalOpenBrowser)({
        browser: browser_1.DEFAULT_BROWSER,
        shouldDumpIo: dumpBrowserLogs,
        browserExecutable,
        chromiumOptions,
        forceDeviceScaleFactor: scale,
        indent,
        viewport: null,
    });
    const browserInstance = puppeteerInstance !== null && puppeteerInstance !== void 0 ? puppeteerInstance : makeBrowser();
    const actualConcurrency = (0, get_concurrency_1.getActualConcurrency)(concurrency);
    const openedPages = [];
    return new Promise((resolve, reject) => {
        const cleanup = [];
        const onError = (err) => {
            reject(err);
        };
        Promise.race([
            new Promise((_, rej) => {
                cancelSignal === null || cancelSignal === void 0 ? void 0 : cancelSignal(() => {
                    rej(new Error(make_cancel_signal_1.cancelErrorMessages.renderFrames));
                });
            }),
            Promise.all([
                (0, prepare_server_1.makeOrReuseServer)(server, {
                    webpackConfigOrServeUrl: webpackBundleOrServeUrl,
                    port,
                    remotionRoot: (0, find_closest_package_json_1.findRemotionRoot)(),
                    concurrency: actualConcurrency,
                    verbose,
                    indent,
                }, {
                    onDownload,
                    onError,
                }),
                browserInstance,
            ]).then(([{ server: { serveUrl, offthreadPort, compositor, sourceMap, downloadMap, }, cleanupServer, }, pInstance,]) => {
                const browserReplacer = (0, replace_browser_1.handleBrowserCrash)(pInstance);
                cleanup.push((0, cycle_browser_tabs_1.cycleBrowserTabs)(browserReplacer, actualConcurrency).stopCycling);
                cleanup.push(() => cleanupServer(false));
                return innerRenderFrames({
                    onError,
                    pagesArray: openedPages,
                    serveUrl,
                    composition,
                    actualConcurrency,
                    onDownload,
                    proxyPort: offthreadPort,
                    makeBrowser,
                    browserReplacer,
                    compositor,
                    sourcemapContext: sourceMap,
                    downloadMap,
                    cancelSignal,
                    envVariables,
                    everyNthFrame,
                    frameRange,
                    imageFormat,
                    inputProps,
                    jpegQuality,
                    muted,
                    onBrowserLog,
                    onFrameBuffer,
                    onFrameUpdate,
                    onStart,
                    outputDir,
                    scale,
                    timeoutInMilliseconds,
                });
            }),
        ])
            .then((res) => {
            return resolve(res);
        })
            .catch((err) => reject(err))
            .finally(() => {
            // If browser instance was passed in, we close all the pages
            // we opened.
            // If new browser was opened, then closing the browser as a cleanup.
            if (puppeteerInstance) {
                Promise.all(openedPages.map((p) => p.close())).catch((err) => {
                    if ((0, is_target_closed_err_1.isTargetClosedErr)(err)) {
                        return;
                    }
                    console.log('Unable to close browser tab', err);
                });
            }
            else {
                Promise.resolve(browserInstance)
                    .then((instance) => {
                    return instance.close(true);
                })
                    .catch((err) => {
                    if (!(err === null || err === void 0 ? void 0 : err.message.includes('Target closed'))) {
                        console.log('Unable to close browser', err);
                    }
                });
            }
            cleanup.forEach((c) => {
                c();
            });
            // Don't clear download dir because it might be used by stitchFramesToVideo
        });
    });
};
exports.internalRenderFrames = internalRenderFrames;
/**
 * @description Renders a series of images using Puppeteer and computes information for mixing audio.
 * @see [Documentation](https://www.remotion.dev/docs/renderer/render-frames)
 */
const renderFrames = (options) => {
    const { composition, inputProps, onFrameUpdate, onStart, outputDir, serveUrl, browserExecutable, cancelSignal, chromiumOptions, concurrency, dumpBrowserLogs, envVariables, everyNthFrame, frameRange, imageFormat, jpegQuality, muted, onBrowserLog, onDownload, onFrameBuffer, port, puppeteerInstance, scale, timeoutInMilliseconds, verbose, quality, } = options;
    if (!composition) {
        throw new Error('No `composition` option has been specified for renderFrames()');
    }
    if (typeof jpegQuality !== 'undefined' && imageFormat !== 'jpeg') {
        throw new Error("You can only pass the `quality` option if `imageFormat` is 'jpeg'.");
    }
    if (quality) {
        console.warn('Passing `quality()` to `renderStill` is deprecated. Use `jpegQuality` instead.');
    }
    return (0, exports.internalRenderFrames)({
        browserExecutable: browserExecutable !== null && browserExecutable !== void 0 ? browserExecutable : null,
        cancelSignal,
        chromiumOptions: chromiumOptions !== null && chromiumOptions !== void 0 ? chromiumOptions : {},
        composition,
        concurrency: concurrency !== null && concurrency !== void 0 ? concurrency : null,
        dumpBrowserLogs: dumpBrowserLogs !== null && dumpBrowserLogs !== void 0 ? dumpBrowserLogs : false,
        envVariables: envVariables !== null && envVariables !== void 0 ? envVariables : {},
        everyNthFrame: everyNthFrame !== null && everyNthFrame !== void 0 ? everyNthFrame : 1,
        frameRange: frameRange !== null && frameRange !== void 0 ? frameRange : null,
        imageFormat: imageFormat !== null && imageFormat !== void 0 ? imageFormat : 'jpeg',
        indent: false,
        jpegQuality: jpegQuality !== null && jpegQuality !== void 0 ? jpegQuality : jpeg_quality_1.DEFAULT_JPEG_QUALITY,
        onDownload: onDownload !== null && onDownload !== void 0 ? onDownload : null,
        inputProps,
        puppeteerInstance,
        muted: muted !== null && muted !== void 0 ? muted : false,
        onBrowserLog: onBrowserLog !== null && onBrowserLog !== void 0 ? onBrowserLog : null,
        onFrameBuffer: onFrameBuffer !== null && onFrameBuffer !== void 0 ? onFrameBuffer : null,
        onFrameUpdate,
        onStart,
        outputDir,
        port: port !== null && port !== void 0 ? port : null,
        scale: scale !== null && scale !== void 0 ? scale : 1,
        verbose: verbose !== null && verbose !== void 0 ? verbose : false,
        timeoutInMilliseconds: timeoutInMilliseconds !== null && timeoutInMilliseconds !== void 0 ? timeoutInMilliseconds : TimeoutSettings_1.DEFAULT_TIMEOUT,
        webpackBundleOrServeUrl: serveUrl,
        server: undefined,
    });
};
exports.renderFrames = renderFrames;
