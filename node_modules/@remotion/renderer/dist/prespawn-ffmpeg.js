"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prespawnFfmpeg = void 0;
const remotion_1 = require("remotion");
const call_ffmpeg_1 = require("./call-ffmpeg");
const codec_1 = require("./codec");
const crf_1 = require("./crf");
const get_codec_name_1 = require("./get-codec-name");
const get_prores_profile_name_1 = require("./get-prores-profile-name");
const logger_1 = require("./logger");
const parse_ffmpeg_progress_1 = require("./parse-ffmpeg-progress");
const pixel_format_1 = require("./pixel-format");
const validate_even_dimensions_with_codec_1 = require("./validate-even-dimensions-with-codec");
const prespawnFfmpeg = (options) => {
    var _a, _b, _c;
    remotion_1.Internals.validateDimension(options.height, 'height', 'passed to `stitchFramesToVideo()`');
    remotion_1.Internals.validateDimension(options.width, 'width', 'passed to `stitchFramesToVideo()`');
    const codec = (_a = options.codec) !== null && _a !== void 0 ? _a : codec_1.DEFAULT_CODEC;
    remotion_1.Internals.validateFps(options.fps, 'in `stitchFramesToVideo()`', codec === 'gif');
    (0, validate_even_dimensions_with_codec_1.validateEvenDimensionsWithCodec)({
        width: options.width,
        height: options.height,
        codec,
        scale: 1,
    });
    const pixelFormat = (_b = options.pixelFormat) !== null && _b !== void 0 ? _b : pixel_format_1.DEFAULT_PIXEL_FORMAT;
    const encoderName = (0, get_codec_name_1.getCodecName)(codec);
    const proResProfileName = (0, get_prores_profile_name_1.getProResProfileName)(codec, options.proResProfile);
    if (encoderName === null) {
        throw new TypeError('encoderName is null: ' + JSON.stringify(options));
    }
    const supportsCrf = codec !== 'prores';
    logger_1.Log.verboseAdvanced({
        indent: options.indent,
        logLevel: options.verbose ? 'verbose' : 'info',
        tag: 'prespawnFfmpeg()',
    }, 'encoder', encoderName);
    logger_1.Log.verboseAdvanced({
        indent: options.indent,
        logLevel: options.verbose ? 'verbose' : 'info',
        tag: 'prespawnFfmpeg()',
    }, 'pixelFormat', pixelFormat);
    if (supportsCrf) {
        logger_1.Log.verboseAdvanced({
            indent: options.indent,
            logLevel: options.verbose ? 'verbose' : 'info',
            tag: 'prespawnFfmpeg()',
        }, 'pixelFormat', options.crf);
    }
    logger_1.Log.verboseAdvanced({
        indent: options.indent,
        logLevel: options.verbose ? 'verbose' : 'info',
        tag: 'prespawnFfmpeg()',
    }, 'codec', codec);
    logger_1.Log.verboseAdvanced({
        indent: options.indent,
        logLevel: options.verbose ? 'verbose' : 'info',
        tag: 'prespawnFfmpeg()',
    }, 'proResProfileName', proResProfileName);
    (0, pixel_format_1.validateSelectedPixelFormatAndCodecCombination)(pixelFormat, codec);
    const ffmpegArgs = [
        ['-r', options.fps.toFixed(2)],
        ...[
            ['-f', 'image2pipe'],
            ['-s', `${options.width}x${options.height}`],
            // If scale is very small (like 0.1), FFMPEG cannot figure out the image
            // format on it's own and we need to hint the format
            ['-vcodec', options.imageFormat === 'jpeg' ? 'mjpeg' : 'png'],
            ['-i', '-'],
        ],
        // -c:v is the same as -vcodec as -codec:video
        // and specified the video codec.
        ['-c:v', encoderName],
        proResProfileName ? ['-profile:v', proResProfileName] : null,
        ['-pix_fmt', pixelFormat],
        // Without explicitly disabling auto-alt-ref,
        // transparent WebM generation doesn't work
        pixelFormat === 'yuva420p' ? ['-auto-alt-ref', '0'] : null,
        ...(0, crf_1.validateQualitySettings)({
            crf: options.crf,
            videoBitrate: options.videoBitrate,
            codec,
        }),
        '-y',
        options.outputLocation,
    ];
    logger_1.Log.verboseAdvanced({
        indent: options.indent,
        logLevel: options.verbose ? 'verbose' : 'info',
        tag: 'prespawnFfmpeg()',
    }, 'Generated FFMPEG command:');
    logger_1.Log.verboseAdvanced({
        indent: options.indent,
        logLevel: options.verbose ? 'verbose' : 'info',
        tag: 'prespawnFfmpeg()',
    }, ffmpegArgs.join(' '));
    const ffmpegString = ffmpegArgs.flat(2).filter(Boolean);
    const finalFfmpegString = options.ffmpegOverride
        ? options.ffmpegOverride({ type: 'pre-stitcher', args: ffmpegString })
        : ffmpegString;
    const task = (0, call_ffmpeg_1.callFf)('ffmpeg', finalFfmpegString);
    options.signal(() => {
        task.kill();
    });
    let ffmpegOutput = '';
    (_c = task.stderr) === null || _c === void 0 ? void 0 : _c.on('data', (data) => {
        const str = data.toString();
        ffmpegOutput += str;
        if (options.onProgress) {
            const parsed = (0, parse_ffmpeg_progress_1.parseFfmpegProgress)(str);
            if (parsed !== undefined) {
                options.onProgress(parsed);
            }
        }
    });
    return { task, getLogs: () => ffmpegOutput };
};
exports.prespawnFfmpeg = prespawnFfmpeg;
