"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serveStatic = void 0;
const node_http_1 = __importDefault(require("node:http"));
const get_port_1 = require("./get-port");
const offthread_video_server_1 = require("./offthread-video-server");
const serve_handler_1 = require("./serve-handler");
const serveStatic = async (path, options) => {
    const { listener: offthreadRequest, close: closeCompositor, compositor, events, } = (0, offthread_video_server_1.startOffthreadVideoServer)({
        downloadMap: options.downloadMap,
        concurrency: options.concurrency,
        verbose: options.verbose,
        indent: options.indent,
    });
    const connections = {};
    const server = node_http_1.default.createServer((request, response) => {
        var _a;
        if ((_a = request.url) === null || _a === void 0 ? void 0 : _a.startsWith('/proxy')) {
            return offthreadRequest(request, response);
        }
        if (path === null) {
            response.writeHead(404);
            response.end('Server only supports /proxy');
            return;
        }
        (0, serve_handler_1.serveHandler)(request, response, {
            public: path,
        }).catch(() => {
            if (!response.headersSent) {
                response.writeHead(500);
            }
            response.end('Error serving file');
        });
    });
    server.on('connection', (conn) => {
        const key = conn.remoteAddress + ':' + conn.remotePort;
        connections[key] = conn;
        conn.on('close', () => {
            delete connections[key];
        });
    });
    let selectedPort = null;
    const maxTries = 5;
    for (let i = 0; i < maxTries; i++) {
        try {
            selectedPort = await new Promise((resolve, reject) => {
                var _a;
                (0, get_port_1.getDesiredPort)((_a = options === null || options === void 0 ? void 0 : options.port) !== null && _a !== void 0 ? _a : undefined, 3000, 3100)
                    .then(({ port, didUsePort }) => {
                    server.listen(port);
                    server.on('listening', () => {
                        resolve(port);
                        return didUsePort();
                    });
                    server.on('error', (err) => {
                        reject(err);
                    });
                })
                    .catch((err) => reject(err));
            });
            const destroyConnections = function () {
                for (const key in connections)
                    connections[key].destroy();
            };
            const close = async () => {
                await Promise.all([
                    closeCompositor(),
                    new Promise((resolve, reject) => {
                        destroyConnections();
                        server.close((err) => {
                            if (err) {
                                if (err.code ===
                                    'ERR_SERVER_NOT_RUNNING') {
                                    return resolve();
                                }
                                reject(err);
                            }
                            else {
                                resolve();
                            }
                        });
                    }),
                ]);
            };
            return { port: selectedPort, close, compositor, events };
        }
        catch (err) {
            if (!(err instanceof Error)) {
                throw err;
            }
            const codedError = err;
            if (codedError.code === 'EADDRINUSE') {
                // Already in use, try another port
            }
            else {
                throw err;
            }
        }
    }
    throw new Error(`Tried ${maxTries} times to find a free port. Giving up.`);
};
exports.serveStatic = serveStatic;
