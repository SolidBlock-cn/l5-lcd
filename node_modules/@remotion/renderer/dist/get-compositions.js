"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCompositions = exports.internalGetCompositions = void 0;
const TimeoutSettings_1 = require("./browser/TimeoutSettings");
const handle_javascript_exception_1 = require("./error-handling/handle-javascript-exception");
const find_closest_package_json_1 = require("./find-closest-package-json");
const get_browser_instance_1 = require("./get-browser-instance");
const prepare_server_1 = require("./prepare-server");
const puppeteer_evaluate_1 = require("./puppeteer-evaluate");
const seek_to_frame_1 = require("./seek-to-frame");
const set_props_and_env_1 = require("./set-props-and-env");
const validate_puppeteer_timeout_1 = require("./validate-puppeteer-timeout");
const innerGetCompositions = async ({ envVariables, inputProps, onBrowserLog, page, proxyPort, serveUrl, timeoutInMilliseconds, }) => {
    if (onBrowserLog) {
        page.on('console', (log) => {
            onBrowserLog({
                stackTrace: log.stackTrace(),
                text: log.text,
                type: log.type,
            });
        });
    }
    (0, validate_puppeteer_timeout_1.validatePuppeteerTimeout)(timeoutInMilliseconds);
    await (0, set_props_and_env_1.setPropsAndEnv)({
        inputProps,
        envVariables,
        page,
        serveUrl,
        initialFrame: 0,
        timeoutInMilliseconds,
        proxyPort,
        retriesRemaining: 2,
        audioEnabled: false,
        videoEnabled: false,
    });
    await (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
        page,
        pageFunction: () => {
            window.remotion_setBundleMode({
                type: 'evaluation',
            });
        },
        frame: null,
        args: [],
    });
    await (0, seek_to_frame_1.waitForReady)(page);
    const result = await (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
        pageFunction: () => {
            return window.getStaticCompositions();
        },
        frame: null,
        page,
        args: [],
    });
    return result;
};
const internalGetCompositions = async ({ browserExecutable, chromiumOptions, envVariables, indent, inputProps, onBrowserLog, port, puppeteerInstance, serveUrlOrWebpackUrl, server, timeoutInMilliseconds, verbose, }) => {
    const { page, cleanup: cleanupPage } = await (0, get_browser_instance_1.getPageAndCleanupFn)({
        passedInInstance: puppeteerInstance,
        browserExecutable,
        chromiumOptions,
        context: null,
        forceDeviceScaleFactor: undefined,
        indent,
        shouldDumpIo: verbose,
    });
    const cleanup = [cleanupPage];
    return new Promise((resolve, reject) => {
        const onError = (err) => reject(err);
        cleanup.push((0, handle_javascript_exception_1.handleJavascriptException)({
            page,
            frame: null,
            onError,
        }));
        (0, prepare_server_1.makeOrReuseServer)(server, {
            webpackConfigOrServeUrl: serveUrlOrWebpackUrl,
            port,
            remotionRoot: (0, find_closest_package_json_1.findRemotionRoot)(),
            concurrency: 1,
            verbose,
            indent,
        }, {
            onDownload: () => undefined,
            onError,
        })
            .then(({ server: { serveUrl, offthreadPort, sourceMap }, cleanupServer }) => {
            page.setBrowserSourceMapContext(sourceMap);
            cleanup.push(() => cleanupServer(true));
            return innerGetCompositions({
                envVariables,
                inputProps,
                onBrowserLog,
                page,
                proxyPort: offthreadPort,
                serveUrl,
                timeoutInMilliseconds,
            });
        })
            .then((comp) => {
            return resolve(comp);
        })
            .catch((err) => {
            reject(err);
        })
            .finally(() => {
            cleanup.forEach((c) => {
                c();
            });
        });
    });
};
exports.internalGetCompositions = internalGetCompositions;
/**
 * @description Gets the compositions defined in a Remotion project based on a Webpack bundle.
 * @see [Documentation](https://www.remotion.dev/docs/renderer/get-compositions)
 */
const getCompositions = (serveUrlOrWebpackUrl, config) => {
    const { browserExecutable, chromiumOptions, envVariables, inputProps, onBrowserLog, port, puppeteerInstance, timeoutInMilliseconds, verbose, } = config !== null && config !== void 0 ? config : {};
    return (0, exports.internalGetCompositions)({
        browserExecutable: browserExecutable !== null && browserExecutable !== void 0 ? browserExecutable : null,
        chromiumOptions: chromiumOptions !== null && chromiumOptions !== void 0 ? chromiumOptions : {},
        envVariables: envVariables !== null && envVariables !== void 0 ? envVariables : {},
        inputProps: inputProps !== null && inputProps !== void 0 ? inputProps : {},
        indent: false,
        onBrowserLog: onBrowserLog !== null && onBrowserLog !== void 0 ? onBrowserLog : null,
        port: port !== null && port !== void 0 ? port : null,
        puppeteerInstance: puppeteerInstance !== null && puppeteerInstance !== void 0 ? puppeteerInstance : undefined,
        serveUrlOrWebpackUrl,
        server: undefined,
        timeoutInMilliseconds: timeoutInMilliseconds !== null && timeoutInMilliseconds !== void 0 ? timeoutInMilliseconds : TimeoutSettings_1.DEFAULT_TIMEOUT,
        verbose: verbose !== null && verbose !== void 0 ? verbose : false,
    });
};
exports.getCompositions = getCompositions;
