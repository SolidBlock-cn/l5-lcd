"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printError = void 0;
const renderer_1 = require("@remotion/renderer");
const chalk_1 = require("./chalk");
const code_frame_1 = require("./code-frame");
const log_1 = require("./log");
const progress_bar_1 = require("./progress-bar");
const should_use_non_overlaying_logger_1 = require("./should-use-non-overlaying-logger");
const printError = async (err, logLevel) => {
    if (err instanceof renderer_1.RenderInternals.SymbolicateableError) {
        const output = (0, progress_bar_1.createOverwriteableCliOutput)({
            quiet: false,
            cancelSignal: null,
            updatesDontOverwrite: (0, should_use_non_overlaying_logger_1.shouldUseNonOverlayingLogger)({ logLevel }),
            indent: false,
        });
        output.update(chalk_1.chalk.red('Symbolicating minified error message...\n' + err.message), false);
        try {
            const symbolicated = await renderer_1.RenderInternals.symbolicateError(err);
            if (symbolicated.frame === null) {
                output.update(chalk_1.chalk.red('An error occurred:'), true);
            }
            else {
                output.update(chalk_1.chalk.red(`An error occurred while rendering frame ${err.frame}:`), true);
            }
            (0, code_frame_1.printCodeFrameAndStack)(symbolicated);
        }
        catch (e) {
            output.update(chalk_1.chalk.red('(Error occurred symbolicating stack trace - printing minified stack trace)'), true);
            log_1.Log.error();
            log_1.Log.error(err.stack || err);
        }
        return;
    }
    log_1.Log.error(err.stack || err);
};
exports.printError = printError;
