"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimelineSequence = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const remotion_1 = require("remotion");
const colors_1 = require("../../helpers/colors");
const get_timeline_sequence_layout_1 = require("../../helpers/get-timeline-sequence-layout");
const timeline_layout_1 = require("../../helpers/timeline-layout");
const AudioWaveform_1 = require("../AudioWaveform");
const LoopedTimelineIndicators_1 = require("./LoopedTimelineIndicators");
const TimelineVideoInfo_1 = require("./TimelineVideoInfo");
const TimelineWidthProvider_1 = require("./TimelineWidthProvider");
const AUDIO_GRADIENT = 'linear-gradient(rgb(16 171 58), rgb(43 165 63) 60%)';
const VIDEO_GRADIENT = 'linear-gradient(to top, #8e44ad, #9b59b6)';
const TimelineSequence = ({ s }) => {
    const windowWidth = (0, react_1.useContext)(TimelineWidthProvider_1.TimelineWidthContext);
    if (windowWidth === null) {
        return null;
    }
    return (0, jsx_runtime_1.jsx)(Inner, { windowWidth: windowWidth, s: s });
};
exports.TimelineSequence = TimelineSequence;
const Inner = ({ s, windowWidth }) => {
    // If a duration is 1, it is essentially a still and it should have width 0
    // Some compositions may not be longer than their media duration,
    // if that is the case, it needs to be asynchronously determined
    const [maxMediaDuration, setMaxMediaDuration] = (0, react_1.useState)(Infinity);
    const video = remotion_1.Internals.useVideo();
    if (!video) {
        throw new TypeError('Expected video config');
    }
    const { marginLeft, width } = (0, react_1.useMemo)(() => {
        return (0, get_timeline_sequence_layout_1.getTimelineSequenceLayout)({
            durationInFrames: s.loopDisplay
                ? s.loopDisplay.durationInFrames * s.loopDisplay.numberOfTimes
                : s.duration,
            startFrom: s.loopDisplay ? s.from + s.loopDisplay.startOffset : s.from,
            startFromMedia: s.type === 'sequence' ? 0 : s.startMediaFrom,
            maxMediaDuration,
            video,
            windowWidth,
        });
    }, [maxMediaDuration, s, video, windowWidth]);
    const style = (0, react_1.useMemo)(() => {
        return {
            background: s.type === 'audio'
                ? AUDIO_GRADIENT
                : s.type === 'video'
                    ? VIDEO_GRADIENT
                    : colors_1.BLUE,
            border: get_timeline_sequence_layout_1.SEQUENCE_BORDER_WIDTH + 'px solid rgba(255, 255, 255, 0.2)',
            borderRadius: 4,
            position: 'absolute',
            height: timeline_layout_1.TIMELINE_LAYER_HEIGHT,
            marginTop: 1,
            marginLeft,
            width,
            color: 'white',
            overflow: 'hidden',
        };
    }, [marginLeft, s.type, width]);
    return ((0, jsx_runtime_1.jsxs)("div", { style: style, title: s.displayName, children: [s.type === 'audio' ? ((0, jsx_runtime_1.jsx)(AudioWaveform_1.AudioWaveform, { src: s.src, doesVolumeChange: s.doesVolumeChange, visualizationWidth: width, startFrom: s.startMediaFrom, durationInFrames: s.duration, volume: s.volume, setMaxMediaDuration: setMaxMediaDuration, playbackRate: s.playbackRate })) : null, s.type === 'video' ? (0, jsx_runtime_1.jsx)(TimelineVideoInfo_1.TimelineVideoInfo, { src: s.src }) : null, s.loopDisplay === undefined ? null : ((0, jsx_runtime_1.jsx)(LoopedTimelineIndicators_1.LoopedTimelineIndicator, { loops: s.loopDisplay.numberOfTimes }))] }, s.id));
};
