import minimist from 'minimist';
export declare const cli: () => Promise<void>;
export * from './render';
export declare const CliInternals: {
    createOverwriteableCliOutput: (options: {
        quiet: boolean;
        cancelSignal: import("@remotion/renderer").CancelSignal | null;
        updatesDontOverwrite: boolean;
        indent: boolean;
    }) => import("./progress-bar").OverwriteableCliOutput;
    chalk: {
        enabled: boolean;
        visible: boolean;
        styles: Record<string, {
            codes: [number, number];
            name: string;
            wrap?: ((input: string, newline: boolean) => string) | undefined;
        }>;
        keys: Record<string, string[]>;
        alias?: ((name: string, col: string) => void) | undefined;
    } & {
        reset: (str: string) => string;
        bold: (str: string) => string;
        dim: (str: string) => string;
        italic: (str: string) => string;
        underline: (str: string) => string;
        inverse: (str: string) => string;
        hidden: (str: string) => string;
        strikethrough: (str: string) => string;
        black: (str: string) => string;
        red: (str: string) => string;
        green: (str: string) => string;
        yellow: (str: string) => string;
        blue: (str: string) => string;
        magenta: (str: string) => string;
        white: (str: string) => string;
        gray: (str: string) => string;
        bgBlack: (str: string) => string;
        bgRed: (str: string) => string;
        bgGreen: (str: string) => string;
        bgYellow: (str: string) => string;
        bgBlue: (str: string) => string;
        bgMagenta: (str: string) => string;
        bgWhite: (str: string) => string;
        blackBright: (str: string) => string;
        redBright: (str: string) => string;
        greenBright: (str: string) => string;
        yellowBright: (str: string) => string;
        blueBright: (str: string) => string;
        magentaBright: (str: string) => string;
        whiteBright: (str: string) => string;
        bgBlackBright: (str: string) => string;
        bgRedBright: (str: string) => string;
        bgGreenBright: (str: string) => string;
        bgYellowBright: (str: string) => string;
        bgBlueBright: (str: string) => string;
        bgMagentaBright: (str: string) => string;
        bgWhiteBright: (str: string) => string;
    };
    makeProgressBar: (percentage: number) => string;
    Log: {
        verbose: (message?: any, ...optionalParams: any[]) => void;
        verboseAdvanced: (options: {
            indent: boolean;
            logLevel: "verbose" | "info" | "warn" | "error";
        } & {
            tag?: string | undefined;
            secondTag?: string | undefined;
        }, message?: any, ...optionalParams: any[]) => void;
        info: (message?: any, ...optionalParams: any[]) => void;
        infoAdvanced: (options: {
            indent: boolean;
            logLevel: "verbose" | "info" | "warn" | "error";
        }, message?: any, ...optionalParams: any[]) => void;
        warn: (message?: any, ...optionalParams: any[]) => void;
        warnAdvanced: (options: {
            indent: boolean;
            logLevel: "verbose" | "info" | "warn" | "error";
        }, message?: any, ...optionalParams: any[]) => void;
        error: (message?: any, ...optionalParams: any[]) => void;
    };
    getCliOptions: (options: {
        isLambda: boolean;
        type: "still" | "series" | "get-compositions";
        remotionRoot: string;
    }) => Promise<{
        puppeteerTimeout: number;
        concurrency: string | number | null;
        frameRange: import("@remotion/renderer").FrameRange | null;
        shouldOutputImageSequence: boolean;
        inputProps: Record<string, unknown>;
        envVariables: Record<string, string>;
        jpegQuality: number;
        browser: import("@remotion/renderer").Browser;
        crf: import("@remotion/renderer").Crf | null;
        pixelFormat: "yuv420p" | "yuva420p" | "yuv422p" | "yuv444p" | "yuv420p10le" | "yuv422p10le" | "yuv444p10le" | "yuva444p10le";
        proResProfile: "4444-xq" | "4444" | "hq" | "standard" | "light" | "proxy" | undefined;
        everyNthFrame: number;
        numberOfGifLoops: import("./config/number-of-gif-loops").Loop;
        stillFrame: number;
        browserExecutable: import("@remotion/renderer").BrowserExecutable;
        logLevel: "verbose" | "info" | "warn" | "error";
        scale: number;
        chromiumOptions: import("@remotion/renderer").ChromiumOptions;
        overwrite: boolean;
        port: number | null;
        muted: boolean;
        enforceAudioTrack: boolean;
        publicDir: string | null;
        ffmpegOverride: import("@remotion/renderer").FfmpegOverrideFn;
        audioBitrate: string | null;
        videoBitrate: string | null;
        height: number | null;
        width: number | null;
        configFileImageFormat: "none" | "png" | "jpeg" | undefined;
    }>;
    loadConfig: (remotionRoot: string) => Promise<string | null>;
    initializeCli: (remotionRoot: string) => Promise<void>;
    BooleanFlags: string[];
    quietFlagProvided: () => boolean;
    parsedCli: {
        "browser-executable": import("@remotion/renderer").BrowserExecutable;
        "pixel-format": "yuv420p" | "yuva420p" | "yuv422p" | "yuv444p" | "yuv420p10le" | "yuv422p10le" | "yuv444p10le" | "yuva444p10le";
        "image-format": "none" | "png" | "jpeg" | "pdf" | "webp";
        "prores-profile": "4444-xq" | "4444" | "hq" | "standard" | "light" | "proxy";
        "bundle-cache": string;
        "env-file": string;
        "ignore-certificate-errors": string;
        "disable-web-security": string;
        "every-nth-frame": number;
        "number-of-gif-loops": number;
        "number-of-shared-audio-tags": number;
        codec: "h264" | "h265" | "vp8" | "vp9" | "mp3" | "aac" | "wav" | "prores" | "h264-mkv" | "gif";
        concurrency: number;
        timeout: number;
        config: string;
        "public-dir": string;
        "audio-bitrate": string;
        "video-bitrate": string;
        "audio-codec": "mp3" | "aac" | "pcm-16" | "opus";
        crf: number;
        force: boolean;
        output: string;
        overwrite: boolean;
        png: boolean;
        props: string;
        quality: number;
        "jpeg-quality": number;
        frames: string | number;
        scale: number;
        sequence: boolean;
        quiet: boolean;
        q: boolean;
        log: string;
        help: boolean;
        port: number;
        frame: string | number;
        "disable-headless": boolean;
        "disable-keyboard-shortcuts": boolean;
        muted: boolean;
        height: number;
        width: number;
        runs: number;
        concurrencies: string;
        "enforce-audio-track": boolean;
        gl: "swangle" | "angle" | "egl" | "swiftshader";
        "package-manager": string;
        "webpack-poll": number;
        "no-open": boolean;
        browser: string;
        "browser-args": string;
        "user-agent": string;
    } & {
        _: string[];
    };
    handleCommonError: (err: Error, logLevel: "verbose" | "info" | "warn" | "error") => Promise<void>;
    formatBytes: (number: number, options?: Intl.NumberFormatOptions & {
        locale: string;
        bits?: boolean | undefined;
        binary?: boolean | undefined;
        signed: boolean;
    }) => string;
    getFileSizeDownloadBar: (downloaded: number) => string;
    determineFinalStillImageFormat: ({ downloadName, outName, configImageFormat, cliFlag, isLambda, fromUi, }: {
        downloadName: string | null;
        outName: string | null;
        configImageFormat: "png" | "jpeg" | "pdf" | "webp" | null;
        cliFlag: "none" | "png" | "jpeg" | "pdf" | "webp" | null;
        isLambda: boolean;
        fromUi: "png" | "jpeg" | "pdf" | "webp" | null;
    }) => {
        format: "png" | "jpeg" | "pdf" | "webp";
        source: string;
    };
    minimist: typeof minimist;
    findEntryPoint: (args: string[], remotionRoot: string) => {
        file: string | null;
        remainingArgs: string[];
        reason: string;
    };
    getVideoImageFormat: ({ codec, uiImageFormat, }: {
        codec: import("@remotion/renderer").CodecOrUndefined;
        uiImageFormat: "none" | "png" | "jpeg" | null;
    }) => "none" | "png" | "jpeg";
    printCompositions: (compositions: import("remotion").AnyCompMetadata[]) => void;
    getFinalOutputCodec: ({ cliFlag, configFile, downloadName, outName, uiCodec, }: {
        cliFlag: import("@remotion/renderer").CodecOrUndefined;
        outName: string | null;
        downloadName: string | null;
        configFile: "h264" | "h265" | "vp8" | "vp9" | "mp3" | "aac" | "wav" | "prores" | "h264-mkv" | "gif" | null;
        uiCodec: "h264" | "h265" | "vp8" | "vp9" | "mp3" | "aac" | "wav" | "prores" | "h264-mkv" | "gif" | null;
    }) => {
        codec: "h264" | "h265" | "vp8" | "vp9" | "mp3" | "aac" | "wav" | "prores" | "h264-mkv" | "gif";
        reason: string;
    };
    listOfRemotionPackages: string[];
    shouldUseNonOverlayingLogger: ({ logLevel, }: {
        logLevel: "verbose" | "info" | "warn" | "error";
    }) => boolean;
    getCompositionWithDimensionOverride: ({ height, width, args, compositionIdFromUi, chromiumOptions, envVariables, port, puppeteerInstance, timeoutInMilliseconds, browserExecutable, serveUrlOrWebpackUrl, indent, inputProps, verbose, server, }: {
        height: number | null;
        width: number | null;
        args: string[];
        compositionIdFromUi: string | null;
        timeoutInMilliseconds: number;
        puppeteerInstance: import("@remotion/renderer").HeadlessBrowser | undefined;
        envVariables: Record<string, string>;
        chromiumOptions: import("@remotion/renderer").ChromiumOptions;
        port: number | null;
        browserExecutable: import("@remotion/renderer").BrowserExecutable;
        serveUrlOrWebpackUrl: string;
        indent: boolean;
        verbose: boolean;
        inputProps: Record<string, unknown>;
        server: import("@remotion/renderer").RemotionServer;
    }) => Promise<{
        compositionId: string;
        reason: string;
        config: import("remotion").AnyCompMetadata;
        argsAfterComposition: string[];
    }>;
};
