"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeRenderingAndStitchingProgress = exports.makeBundlingAndCopyProgress = exports.createOverwriteableCliOutput = void 0;
const renderer_1 = require("@remotion/renderer");
const ansi_diff_1 = require("./ansi/ansi-diff");
const chalk_1 = require("./chalk");
const download_progress_1 = require("./download-progress");
const make_progress_bar_1 = require("./make-progress-bar");
const truthy_1 = require("./truthy");
const createOverwriteableCliOutput = (options) => {
    var _a;
    if (options.quiet) {
        return {
            update: () => false,
        };
    }
    if (options.updatesDontOverwrite) {
        return {
            update: (up) => {
                if (options.indent) {
                    process.stdout.write(up
                        .split('\n')
                        .filter((a) => a.trim())
                        .map((l) => {
                        return `${renderer_1.RenderInternals.INDENT_TOKEN} ${l}`;
                    })
                        .join('\n'));
                }
                else {
                    process.stdout.write(up + '\n');
                }
                return true;
            },
        };
    }
    const diff = new ansi_diff_1.AnsiDiff();
    (_a = options.cancelSignal) === null || _a === void 0 ? void 0 : _a.call(options, () => {
        process.stdout.write(diff.finish());
    });
    return {
        update: (up, newline) => {
            if (options.indent) {
                return process.stdout.write(diff.update(up
                    .split('\n')
                    .filter((a) => a.trim())
                    .map((l) => `${renderer_1.RenderInternals.INDENT_TOKEN} ${l}`)
                    .join('\n') + (newline ? '\n' : '')));
            }
            return process.stdout.write(diff.update(up + (newline ? '\n' : '')));
        },
    };
};
exports.createOverwriteableCliOutput = createOverwriteableCliOutput;
const makeBundlingProgress = ({ bundlingState, bundlingStep, steps, }) => {
    const { doneIn, progress } = bundlingState;
    return [
        `(${bundlingStep + 1}/${steps})`,
        (0, make_progress_bar_1.makeProgressBar)(progress),
        `${doneIn ? 'Bundled' : 'Bundling'} code`,
        doneIn === null
            ? (progress * 100).toFixed(0) + '%'
            : chalk_1.chalk.gray(`${doneIn}ms`),
    ]
        .filter(truthy_1.truthy)
        .join(' ');
};
const makeCopyingProgress = (options) => {
    // Don't show copy progress lower than 200MB
    if (options.bytes < 1000 * 1000 * 200) {
        return null;
    }
    return [
        '    +',
        options.doneIn ? (0, make_progress_bar_1.makeProgressBar)(1) : (0, download_progress_1.getFileSizeDownloadBar)(options.bytes),
        'Copying public dir',
        options.doneIn === null ? null : chalk_1.chalk.gray(`${options.doneIn}ms`),
    ]
        .filter(truthy_1.truthy)
        .join(' ');
};
const makeSymlinkProgress = (options) => {
    if (options.symlinks.length === 0) {
        return null;
    }
    if (options.symlinks.length === 1) {
        return [
            chalk_1.chalk.gray(`      Found a symbolic link in the public folder:`),
            chalk_1.chalk.gray('      ' + options.symlinks[0]),
            chalk_1.chalk.gray('      The symlink will be forwarded in to the bundle.'),
        ].join('\n');
    }
    return [
        chalk_1.chalk.gray(`      Found ${options.symlinks.length} symbolic links in the public folder.`),
        chalk_1.chalk.gray('      The symlinks will be forwarded in to the bundle.'),
    ].join('\n');
};
const makeBundlingAndCopyProgress = ({ bundling, copying, symLinks, }, bundlingStep, steps) => {
    return [
        makeBundlingProgress({
            bundlingState: bundling,
            bundlingStep,
            steps,
        }),
        makeCopyingProgress(copying),
        makeSymlinkProgress(symLinks),
    ]
        .filter(truthy_1.truthy)
        .join('\n');
};
exports.makeBundlingAndCopyProgress = makeBundlingAndCopyProgress;
const makeRenderingProgress = ({ frames, totalFrames, steps, concurrency, doneIn, }) => {
    const progress = frames / totalFrames;
    return [
        `(${steps.indexOf('rendering') + 1}/${steps.length})`,
        (0, make_progress_bar_1.makeProgressBar)(progress),
        [doneIn ? 'Rendered' : 'Rendering', `frames (${concurrency}x)`]
            .filter(truthy_1.truthy)
            .join(' '),
        doneIn === null ? `${frames}/${totalFrames}` : chalk_1.chalk.gray(`${doneIn}ms`),
    ]
        .filter(truthy_1.truthy)
        .join(' ');
};
const makeStitchingProgress = ({ stitchingProgress, steps, stitchingStep, }) => {
    const { frames, totalFrames, doneIn, stage, codec } = stitchingProgress;
    const progress = frames / totalFrames;
    const mediaType = codec === 'gif'
        ? 'GIF'
        : renderer_1.RenderInternals.isAudioCodec(codec)
            ? 'audio'
            : 'video';
    return [
        `(${stitchingStep + 1}/${steps})`,
        (0, make_progress_bar_1.makeProgressBar)(progress),
        stage === 'muxing' && renderer_1.RenderInternals.canUseParallelEncoding(codec)
            ? `${doneIn ? 'Muxed' : 'Muxing'} ${mediaType}`
            : `${doneIn ? 'Encoded' : 'Encoding'} ${mediaType}`,
        doneIn === null ? `${frames}/${totalFrames}` : chalk_1.chalk.gray(`${doneIn}ms`),
    ]
        .filter(truthy_1.truthy)
        .join(' ');
};
const makeRenderingAndStitchingProgress = ({ prog, steps, stitchingStep, }) => {
    const { rendering, stitching, downloads, bundling } = prog;
    const output = [
        rendering ? makeRenderingProgress(rendering) : null,
        (0, download_progress_1.makeMultiDownloadProgress)(downloads),
        stitching === null
            ? null
            : makeStitchingProgress({
                stitchingProgress: stitching,
                steps,
                stitchingStep,
            }),
    ]
        .filter(truthy_1.truthy)
        .join('\n');
    const renderProgress = rendering
        ? rendering.frames / rendering.totalFrames
        : 0;
    const stitchingProgress = stitching
        ? stitching.frames / stitching.totalFrames
        : 0;
    const progress = bundling.progress * 0.3 + renderProgress * 0.6 + stitchingProgress * 0.1;
    return { output, progress, message: getGuiProgressSubtitle(prog) };
};
exports.makeRenderingAndStitchingProgress = makeRenderingAndStitchingProgress;
const getGuiProgressSubtitle = (progress) => {
    // Handle floating point inaccuracies
    if (progress.bundling.progress < 0.99999) {
        return `Bundling ${Math.round(progress.bundling.progress * 100)}%`;
    }
    if (progress.copyingState.doneIn === null) {
        if (progress.copyingState.bytes < 100000000) {
            return 'Bundling 100%';
        }
        const bytes = new Intl.NumberFormat('en', {
            notation: 'compact',
            style: 'unit',
            unit: 'byte',
            unitDisplay: 'narrow',
        });
        return `Copying ${bytes.format(progress.copyingState.bytes)}`;
    }
    if (!progress.rendering) {
        return `Getting compositions`;
    }
    const allRendered = progress.rendering.frames === progress.rendering.totalFrames;
    if (!allRendered || !progress.stitching || progress.stitching.frames === 0) {
        return `Rendering ${progress.rendering.frames}/${progress.rendering.totalFrames}`;
    }
    return `Stitching ${progress.stitching.frames}/${progress.stitching.totalFrames}`;
};
