"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleRoutes = void 0;
const bundler_1 = require("@remotion/bundler");
const renderer_1 = require("@remotion/renderer");
const node_fs_1 = require("node:fs");
const node_path_1 = __importDefault(require("node:path"));
const node_url_1 = require("node:url");
const config_1 = require("../config");
const number_of_shared_audio_tags_1 = require("../config/number-of-shared-audio-tags");
const parse_command_line_1 = require("../parse-command-line");
const api_routes_1 = require("./api-routes");
const get_file_source_1 = require("./error-overlay/react-overlay/utils/get-file-source");
const open_in_editor_1 = require("./error-overlay/react-overlay/utils/open-in-editor");
const get_package_manager_1 = require("./get-package-manager");
const handler_1 = require("./handler");
const parse_body_1 = require("./parse-body");
const project_info_1 = require("./project-info");
const public_folder_1 = require("./public-folder");
const queue_1 = require("./render-queue/queue");
const serve_static_1 = require("./serve-static");
const editorGuess = (0, open_in_editor_1.guessEditor)();
const static404 = (response) => {
    response.writeHead(404);
    response.end('The static/ prefix has been changed, this URL is no longer valid.');
};
const handleFallback = async ({ remotionRoot, hash, response, getCurrentInputProps, getEnvVariables, publicDir, }) => {
    var _a, _b;
    const [edit] = await editorGuess;
    const displayName = (0, open_in_editor_1.getDisplayNameForEditor)(edit ? edit.command : null);
    const defaultJpegQuality = config_1.ConfigInternals.getJpegQuality();
    const defaultScale = config_1.ConfigInternals.getScale();
    const logLevel = config_1.ConfigInternals.Logging.getLogLevel();
    const defaultCodec = config_1.ConfigInternals.getOutputCodecOrUndefined();
    const concurrency = renderer_1.RenderInternals.getActualConcurrency(config_1.ConfigInternals.getConcurrency());
    const muted = config_1.ConfigInternals.getMuted();
    const enforceAudioTrack = config_1.ConfigInternals.getEnforceAudioTrack();
    const pixelFormat = config_1.ConfigInternals.getPixelFormat();
    const proResProfile = (_a = config_1.ConfigInternals.getProResProfile()) !== null && _a !== void 0 ? _a : 'hq';
    const audioBitrate = config_1.ConfigInternals.getAudioBitrate();
    const videoBitrate = config_1.ConfigInternals.getVideoBitrate();
    const everyNthFrame = config_1.ConfigInternals.getEveryNthFrame();
    const numberOfGifLoops = config_1.ConfigInternals.getNumberOfGifLoops();
    const delayRenderTimeout = config_1.ConfigInternals.getCurrentPuppeteerTimeout();
    const audioCodec = config_1.ConfigInternals.getAudioCodec();
    const stillImageFormat = config_1.ConfigInternals.getUserPreferredStillImageFormat();
    const videoImageFormat = config_1.ConfigInternals.getUserPreferredVideoImageFormat();
    const disableWebSecurity = config_1.ConfigInternals.getChromiumDisableWebSecurity();
    const headless = config_1.ConfigInternals.getChromiumHeadlessMode();
    const ignoreCertificateErrors = config_1.ConfigInternals.getIgnoreCertificateErrors();
    const openGlRenderer = config_1.ConfigInternals.getChromiumOpenGlRenderer();
    const maxConcurrency = renderer_1.RenderInternals.getMaxConcurrency();
    const minConcurrency = renderer_1.RenderInternals.getMinConcurrency();
    response.setHeader('content-type', 'text/html');
    response.writeHead(200);
    const packageManager = (0, get_package_manager_1.getPackageManager)(remotionRoot, undefined);
    (0, public_folder_1.fetchFolder)({ publicDir, staticHash: hash });
    response.end(bundler_1.BundlerInternals.indexHtml({
        staticHash: hash,
        baseDir: '/',
        editorName: displayName,
        envVariables: getEnvVariables(),
        inputProps: getCurrentInputProps(),
        remotionRoot,
        studioServerCommand: packageManager === 'unknown' ? null : packageManager.startCommand,
        renderQueue: (0, queue_1.getRenderQueue)(),
        numberOfAudioTags: (_b = parse_command_line_1.parsedCli['number-of-shared-audio-tags']) !== null && _b !== void 0 ? _b : (0, number_of_shared_audio_tags_1.getNumberOfSharedAudioTags)(),
        publicFiles: (0, public_folder_1.getFiles)(),
        includeFavicon: true,
        title: 'Remotion Studio',
        renderDefaults: {
            jpegQuality: defaultJpegQuality !== null && defaultJpegQuality !== void 0 ? defaultJpegQuality : renderer_1.RenderInternals.DEFAULT_JPEG_QUALITY,
            scale: defaultScale !== null && defaultScale !== void 0 ? defaultScale : 1,
            logLevel,
            codec: defaultCodec !== null && defaultCodec !== void 0 ? defaultCodec : 'h264',
            concurrency,
            maxConcurrency,
            minConcurrency,
            stillImageFormat: stillImageFormat !== null && stillImageFormat !== void 0 ? stillImageFormat : renderer_1.RenderInternals.DEFAULT_STILL_IMAGE_FORMAT,
            videoImageFormat: videoImageFormat !== null && videoImageFormat !== void 0 ? videoImageFormat : renderer_1.RenderInternals.DEFAULT_VIDEO_IMAGE_FORMAT,
            muted,
            enforceAudioTrack,
            proResProfile,
            pixelFormat,
            audioBitrate,
            videoBitrate,
            everyNthFrame,
            numberOfGifLoops,
            delayRenderTimeout,
            audioCodec,
            disableWebSecurity,
            headless,
            ignoreCertificateErrors,
            openGlRenderer,
        },
    }));
};
const handleProjectInfo = async (remotionRoot, _, response) => {
    const data = await (0, project_info_1.getProjectInfo)(remotionRoot);
    response.setHeader('content-type', 'application/json');
    response.writeHead(200);
    response.end(JSON.stringify(data));
};
const handleFileSource = async ({ method, remotionRoot, search, response, }) => {
    if (method === 'OPTIONS') {
        response.writeHead(200);
        response.end();
        return;
    }
    if (!search.startsWith('?')) {
        throw new Error('query must start with ?');
    }
    const query = new node_url_1.URLSearchParams(search);
    const f = query.get('f');
    if (typeof f !== 'string') {
        throw new Error('must pass `f` parameter');
    }
    const data = await (0, get_file_source_1.getFileSource)(remotionRoot, decodeURIComponent(f));
    response.writeHead(200);
    response.write(data);
    return response.end();
};
const handleOpenInEditor = async (remotionRoot, req, res) => {
    if (req.method === 'OPTIONS') {
        res.statusCode = 200;
        res.end();
        return;
    }
    try {
        const body = (await (0, parse_body_1.parseRequestBody)(req));
        if (!('stack' in body)) {
            throw new TypeError('Need to pass stack');
        }
        const stack = body.stack;
        const guess = await editorGuess;
        const didOpen = await (0, open_in_editor_1.launchEditor)({
            colNumber: stack.originalColumnNumber,
            editor: guess[0],
            fileName: node_path_1.default.resolve(remotionRoot, stack.originalFileName),
            lineNumber: stack.originalLineNumber,
            vsCodeNewWindow: false,
        });
        res.setHeader('content-type', 'application/json');
        res.writeHead(200);
        res.end(JSON.stringify({
            success: didOpen,
        }));
    }
    catch (err) {
        res.setHeader('content-type', 'application/json');
        res.writeHead(200);
        res.end(JSON.stringify({
            success: false,
        }));
    }
};
const handleFavicon = (_, response) => {
    const filePath = node_path_1.default.join(__dirname, '..', '..', 'web', 'favicon.png');
    const stat = (0, node_fs_1.statSync)(filePath);
    response.writeHead(200, {
        'Content-Type': 'image/png',
        'Content-Length': stat.size,
    });
    const readStream = (0, node_fs_1.createReadStream)(filePath);
    readStream.pipe(response);
};
const handleRoutes = ({ hash, hashPrefix, request, response, liveEventsServer, getCurrentInputProps, getEnvVariables, remotionRoot, entryPoint, publicDir, }) => {
    const url = new URL(request.url, 'http://localhost');
    if (url.pathname === '/api/project-info') {
        return handleProjectInfo(remotionRoot, request, response);
    }
    if (url.pathname === '/api/file-source') {
        return handleFileSource({
            remotionRoot,
            search: url.search,
            method: request.method,
            response,
        });
    }
    if (url.pathname === '/api/open-in-editor') {
        return handleOpenInEditor(remotionRoot, request, response);
    }
    for (const [key, value] of Object.entries(api_routes_1.allApiRoutes)) {
        if (url.pathname === key) {
            return (0, handler_1.handleRequest)({
                remotionRoot,
                entryPoint,
                handler: value,
                request,
                response,
            });
        }
    }
    if (url.pathname === '/remotion.png') {
        return handleFavicon(request, response);
    }
    if (url.pathname === '/events') {
        return liveEventsServer.router(request, response);
    }
    if (url.pathname.startsWith(hash)) {
        return (0, serve_static_1.serveStatic)(publicDir, hash, request, response);
    }
    if (url.pathname.startsWith(hashPrefix)) {
        return static404(response);
    }
    return handleFallback({
        remotionRoot,
        hash,
        response,
        getCurrentInputProps,
        getEnvVariables,
        publicDir,
    });
};
exports.handleRoutes = handleRoutes;
