"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.benchmarkCommand = void 0;
const renderer_1 = require("@remotion/renderer");
const chalk_1 = require("./chalk");
const cleanup_before_quit_1 = require("./cleanup-before-quit");
const config_1 = require("./config");
const convert_entry_point_to_serve_url_1 = require("./convert-entry-point-to-serve-url");
const entry_point_1 = require("./entry-point");
const get_cli_options_1 = require("./get-cli-options");
const get_final_output_codec_1 = require("./get-final-output-codec");
const image_formats_1 = require("./image-formats");
const log_1 = require("./log");
const make_progress_bar_1 = require("./make-progress-bar");
const parse_command_line_1 = require("./parse-command-line");
const progress_bar_1 = require("./progress-bar");
const setup_cache_1 = require("./setup-cache");
const should_use_non_overlaying_logger_1 = require("./should-use-non-overlaying-logger");
const show_compositions_picker_1 = require("./show-compositions-picker");
const truthy_1 = require("./truthy");
const DEFAULT_RUNS = 3;
const getValidConcurrency = (cliConcurrency) => {
    const { concurrencies } = parse_command_line_1.parsedCli;
    if (!concurrencies) {
        return [renderer_1.RenderInternals.getActualConcurrency(cliConcurrency)];
    }
    return concurrencies
        .split(',')
        .map((c) => parseInt(c.trim(), 10));
};
const runBenchmark = async (runs, options, onProgress) => {
    const timeTaken = [];
    for (let run = 0; run < runs; ++run) {
        const startTime = performance.now();
        await renderer_1.RenderInternals.internalRenderMedia({
            onProgress: ({ progress }) => onProgress === null || onProgress === void 0 ? void 0 : onProgress(run, progress),
            ...options,
        });
        const endTime = performance.now();
        timeTaken.push(endTime - startTime);
    }
    return timeTaken;
};
const formatTime = (time) => {
    let ret = '';
    const hours = Math.floor(time / (60 * 60 * 1000));
    if (hours) {
        ret = `${hours}h`;
    }
    time %= 60 * 60 * 1000;
    const minutes = Math.floor(time / (60 * 1000));
    if (minutes) {
        ret = `${ret}${minutes}m`;
    }
    time %= 60 * 1000;
    const seconds = (time / 1000).toFixed(5);
    if (seconds) {
        ret = `${ret}${seconds}s`;
    }
    return ret;
};
const avg = (time) => time.reduce((prev, curr) => prev + curr) / time.length;
const stdDev = (time) => {
    const mean = avg(time);
    return Math.sqrt(time.map((x) => (x - mean) ** 2).reduce((a, b) => a + b) / time.length);
};
const getResults = (results, runs) => {
    const mean = avg(results);
    const dev = stdDev(results);
    const max = Math.max(...results);
    const min = Math.min(...results);
    return `    Time (${chalk_1.chalk.green('mean')} ± ${chalk_1.chalk.green('σ')}):         ${chalk_1.chalk.green(formatTime(mean))} ± ${chalk_1.chalk.green(formatTime(dev))}\n    Range (${chalk_1.chalk.blue('min')} ... ${chalk_1.chalk.red('max')}):     ${chalk_1.chalk.blue(formatTime(min))} ... ${chalk_1.chalk.red(formatTime(max))} \t ${chalk_1.chalk.gray(`${runs} runs`)}
	`;
};
const makeBenchmarkProgressBar = ({ totalRuns, run, progress, doneIn, }) => {
    const totalProgress = (run + progress) / totalRuns;
    return [
        `Rendering (${run + 1} out of ${totalRuns} runs)`,
        (0, make_progress_bar_1.makeProgressBar)(totalProgress),
        doneIn === null
            ? `${(totalProgress * 100).toFixed(2)}% `
            : chalk_1.chalk.gray(doneIn),
    ].join(' ');
};
const benchmarkCommand = async (remotionRoot, args) => {
    var _a, _b;
    const runs = (_a = parse_command_line_1.parsedCli.runs) !== null && _a !== void 0 ? _a : DEFAULT_RUNS;
    const { file, reason, remainingArgs } = (0, entry_point_1.findEntryPoint)(args, remotionRoot);
    if (!file) {
        log_1.Log.error('No entry file passed.');
        log_1.Log.info('Pass an additional argument specifying the entry file');
        log_1.Log.info();
        log_1.Log.info(`$ remotion benchmark <entry file>`);
        process.exit(1);
    }
    const fullEntryPoint = (0, convert_entry_point_to_serve_url_1.convertEntryPointToServeUrl)(file);
    const { inputProps, envVariables, browserExecutable, chromiumOptions, port, puppeteerTimeout, browser, scale, publicDir, proResProfile, frameRange: defaultFrameRange, overwrite, jpegQuality, crf: configFileCrf, pixelFormat, scale: configFileScale, numberOfGifLoops, everyNthFrame, muted, enforceAudioTrack, ffmpegOverride, audioBitrate, videoBitrate, height, width, concurrency: unparsedConcurrency, logLevel, } = await (0, get_cli_options_1.getCliOptions)({
        isLambda: false,
        type: 'series',
        remotionRoot,
    });
    log_1.Log.verbose('Entry point:', fullEntryPoint, 'reason:', reason);
    const browserInstance = renderer_1.RenderInternals.internalOpenBrowser({
        browser,
        browserExecutable,
        shouldDumpIo: renderer_1.RenderInternals.isEqualOrBelowLogLevel(config_1.ConfigInternals.Logging.getLogLevel(), 'verbose'),
        chromiumOptions,
        forceDeviceScaleFactor: scale,
        indent: false,
        viewport: null,
    });
    const { urlOrBundle: bundleLocation, cleanup: cleanupBundle } = await (0, setup_cache_1.bundleOnCliOrTakeServeUrl)({
        fullPath: fullEntryPoint,
        publicDir,
        remotionRoot,
        onProgress: () => undefined,
        indentOutput: false,
        logLevel: config_1.ConfigInternals.Logging.getLogLevel(),
        bundlingStep: 0,
        steps: 1,
        onDirectoryCreated: (dir) => {
            (0, cleanup_before_quit_1.registerCleanupJob)(() => renderer_1.RenderInternals.deleteDirectory(dir));
        },
        quietProgress: false,
    });
    (0, cleanup_before_quit_1.registerCleanupJob)(() => cleanupBundle());
    const puppeteerInstance = await browserInstance;
    const verbose = renderer_1.RenderInternals.isEqualOrBelowLogLevel(config_1.ConfigInternals.Logging.getLogLevel(), 'verbose');
    const comps = await renderer_1.RenderInternals.internalGetCompositions({
        serveUrlOrWebpackUrl: bundleLocation,
        inputProps,
        envVariables,
        chromiumOptions,
        timeoutInMilliseconds: puppeteerTimeout,
        port,
        puppeteerInstance,
        browserExecutable,
        indent: false,
        onBrowserLog: null,
        //  Intentionally disabling server to not cache results
        server: undefined,
        verbose,
    });
    const ids = (remainingArgs[0]
        ? remainingArgs[0]
            .split(',')
            .map((c) => c.trim())
            .filter(truthy_1.truthy)
        : await (0, show_compositions_picker_1.showMultiCompositionsPicker)(comps));
    const compositions = ids.map((compId) => {
        const composition = comps.find((c) => c.id === compId);
        if (!composition) {
            throw new Error(`No composition with the ID "${compId}" found.`);
        }
        return composition;
    });
    if (compositions.length === 0) {
        log_1.Log.error('No composition IDs passed. Add another argument to the command specifying at least 1 composition ID.');
    }
    const benchmark = {};
    let count = 1;
    const { codec, reason: codecReason } = (0, get_final_output_codec_1.getFinalOutputCodec)({
        cliFlag: parse_command_line_1.parsedCli.codec,
        downloadName: null,
        outName: null,
        configFile: (_b = config_1.ConfigInternals.getOutputCodecOrUndefined()) !== null && _b !== void 0 ? _b : null,
        uiCodec: null,
    });
    for (const composition of compositions) {
        const concurrency = getValidConcurrency(unparsedConcurrency);
        benchmark[composition.id] = {};
        for (const con of concurrency) {
            const benchmarkProgress = (0, progress_bar_1.createOverwriteableCliOutput)({
                quiet: (0, parse_command_line_1.quietFlagProvided)(),
                cancelSignal: null,
                updatesDontOverwrite: (0, should_use_non_overlaying_logger_1.shouldUseNonOverlayingLogger)({ logLevel }),
                indent: false,
            });
            log_1.Log.info();
            log_1.Log.info(`${chalk_1.chalk.bold(`Benchmark #${count++}:`)} ${chalk_1.chalk.gray(`composition=${composition.id} concurrency=${con} codec=${codec} (${codecReason})`)}`);
            const timeTaken = await runBenchmark(runs, {
                outputLocation: null,
                composition: {
                    ...composition,
                    width: width !== null && width !== void 0 ? width : composition.width,
                    height: height !== null && height !== void 0 ? height : composition.height,
                },
                crf: configFileCrf !== null && configFileCrf !== void 0 ? configFileCrf : null,
                envVariables,
                frameRange: defaultFrameRange,
                imageFormat: (0, image_formats_1.getVideoImageFormat)({
                    codec,
                    uiImageFormat: null,
                }),
                inputProps,
                overwrite,
                pixelFormat,
                proResProfile,
                jpegQuality,
                dumpBrowserLogs: verbose,
                chromiumOptions,
                timeoutInMilliseconds: config_1.ConfigInternals.getCurrentPuppeteerTimeout(),
                scale: configFileScale,
                port,
                numberOfGifLoops,
                everyNthFrame,
                verbose,
                muted,
                enforceAudioTrack,
                browserExecutable,
                ffmpegOverride,
                serveUrl: bundleLocation,
                codec,
                audioBitrate,
                videoBitrate,
                puppeteerInstance,
                concurrency: con,
                audioCodec: null,
                cancelSignal: undefined,
                disallowParallelEncoding: false,
                indent: false,
                onBrowserLog: null,
                onCtrlCExit: () => undefined,
                onDownload: () => undefined,
                onStart: () => undefined,
                preferLossless: false,
                server: undefined,
            }, (run, progress) => {
                benchmarkProgress.update(makeBenchmarkProgressBar({
                    totalRuns: runs,
                    run,
                    doneIn: null,
                    progress,
                }), false);
            });
            benchmarkProgress.update('', false);
            benchmarkProgress.update(getResults(timeTaken, runs), false);
            benchmark[composition.id][`${con}`] = timeTaken;
        }
    }
    log_1.Log.info();
};
exports.benchmarkCommand = benchmarkCommand;
