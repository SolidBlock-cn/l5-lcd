"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CliInternals = exports.cli = void 0;
const renderer_1 = require("@remotion/renderer");
const minimist_1 = __importDefault(require("minimist"));
const benchmark_1 = require("./benchmark");
const chalk_1 = require("./chalk");
const cleanup_before_quit_1 = require("./cleanup-before-quit");
const compositions_1 = require("./compositions");
const config_1 = require("./config");
const determine_image_format_1 = require("./determine-image-format");
const download_progress_1 = require("./download-progress");
const entry_point_1 = require("./entry-point");
const ffmpeg_1 = require("./ffmpeg");
const format_bytes_1 = require("./format-bytes");
const get_cli_options_1 = require("./get-cli-options");
const get_composition_with_dimension_override_1 = require("./get-composition-with-dimension-override");
const get_config_file_name_1 = require("./get-config-file-name");
const get_final_output_codec_1 = require("./get-final-output-codec");
const handle_common_errors_1 = require("./handle-common-errors");
const image_formats_1 = require("./image-formats");
const initialize_cli_1 = require("./initialize-cli");
const lambda_command_1 = require("./lambda-command");
const list_of_remotion_packages_1 = require("./list-of-remotion-packages");
const log_1 = require("./log");
const make_progress_bar_1 = require("./make-progress-bar");
const parse_command_line_1 = require("./parse-command-line");
const print_compositions_1 = require("./print-compositions");
const print_help_1 = require("./print-help");
const progress_bar_1 = require("./progress-bar");
const render_1 = require("./render");
const should_use_non_overlaying_logger_1 = require("./should-use-non-overlaying-logger");
const still_1 = require("./still");
const studio_1 = require("./studio");
const upgrade_1 = require("./upgrade");
const versions_1 = require("./versions");
const cli = async () => {
    const [command, ...args] = parse_command_line_1.parsedCli._;
    if (parse_command_line_1.parsedCli.help) {
        (0, print_help_1.printHelp)();
        process.exit(0);
    }
    const remotionRoot = renderer_1.RenderInternals.findRemotionRoot();
    if (command !== versions_1.VERSIONS_COMMAND) {
        await (0, versions_1.validateVersionsBeforeCommand)(remotionRoot);
    }
    const errorSymbolicationLock = renderer_1.RenderInternals.registerErrorSymbolicationLock();
    (0, cleanup_before_quit_1.handleCtrlC)();
    await (0, initialize_cli_1.initializeCli)(remotionRoot);
    try {
        if (command === 'compositions') {
            await (0, compositions_1.listCompositionsCommand)(remotionRoot, args);
        }
        else if (command === 'preview' || command === 'studio') {
            await (0, studio_1.studioCommand)(remotionRoot, args);
        }
        else if (command === 'lambda') {
            await (0, lambda_command_1.lambdaCommand)(remotionRoot, args);
        }
        else if (command === 'render') {
            await (0, render_1.render)(remotionRoot, args);
        }
        else if (command === 'still') {
            await (0, still_1.still)(remotionRoot, args);
        }
        else if (command === 'ffmpeg') {
            (0, ffmpeg_1.ffmpegCommand)(remotionRoot, process.argv.slice(3));
        }
        else if (command === 'ffprobe') {
            (0, ffmpeg_1.ffprobeCommand)(remotionRoot, process.argv.slice(3));
        }
        else if (command === 'upgrade') {
            await (0, upgrade_1.upgrade)(remotionRoot, parse_command_line_1.parsedCli['package-manager']);
        }
        else if (command === versions_1.VERSIONS_COMMAND) {
            await (0, versions_1.versionsCommand)(remotionRoot);
        }
        else if (command === 'benchmark') {
            await (0, benchmark_1.benchmarkCommand)(remotionRoot, args);
        }
        else if (command === 'help') {
            (0, print_help_1.printHelp)();
            process.exit(0);
        }
        else {
            if (command) {
                log_1.Log.error(`Command ${command} not found.`);
            }
            (0, print_help_1.printHelp)();
            process.exit(1);
        }
    }
    catch (err) {
        log_1.Log.info();
        await (0, handle_common_errors_1.handleCommonError)(err, config_1.ConfigInternals.Logging.getLogLevel());
        (0, cleanup_before_quit_1.cleanupBeforeQuit)();
        process.exit(1);
    }
    finally {
        renderer_1.RenderInternals.unlockErrorSymbolicationLock(errorSymbolicationLock);
        (0, cleanup_before_quit_1.cleanupBeforeQuit)();
    }
};
exports.cli = cli;
__exportStar(require("./render"), exports);
exports.CliInternals = {
    createOverwriteableCliOutput: progress_bar_1.createOverwriteableCliOutput,
    chalk: chalk_1.chalk,
    makeProgressBar: make_progress_bar_1.makeProgressBar,
    Log: log_1.Log,
    getCliOptions: get_cli_options_1.getCliOptions,
    loadConfig: get_config_file_name_1.loadConfig,
    initializeCli: initialize_cli_1.initializeCli,
    BooleanFlags: parse_command_line_1.BooleanFlags,
    quietFlagProvided: parse_command_line_1.quietFlagProvided,
    parsedCli: parse_command_line_1.parsedCli,
    handleCommonError: handle_common_errors_1.handleCommonError,
    formatBytes: format_bytes_1.formatBytes,
    getFileSizeDownloadBar: download_progress_1.getFileSizeDownloadBar,
    determineFinalStillImageFormat: determine_image_format_1.determineFinalStillImageFormat,
    minimist: minimist_1.default,
    findEntryPoint: entry_point_1.findEntryPoint,
    getVideoImageFormat: image_formats_1.getVideoImageFormat,
    printCompositions: print_compositions_1.printCompositions,
    getFinalOutputCodec: get_final_output_codec_1.getFinalOutputCodec,
    listOfRemotionPackages: list_of_remotion_packages_1.listOfRemotionPackages,
    shouldUseNonOverlayingLogger: should_use_non_overlaying_logger_1.shouldUseNonOverlayingLogger,
    getCompositionWithDimensionOverride: get_composition_with_dimension_override_1.getCompositionWithDimensionOverride,
};
